{"version":3,"file":"index.cjs","names":["data: unknown","value: unknown","acceptEventTypes: WorkflowEvent<any>[]","inputEventData: WorkflowEventData<any>[]","acceptance: WorkflowEventData<any>[]","i","subscribable: Subscribable<Args, R>","callback: (...args: Args) => R","queue: WorkflowEventData<any>[]","handler: Handler<WorkflowEvent<any>[], any>","inputEvents: WorkflowEvent<any>[]","inputs: WorkflowEventData<any>[]","parentContext: HandlerContext","handlerAbortController: AbortController","handlerContext: HandlerContext","i","context: HandlerContext","result: any","unsubscribe: () => void","newEvent: WorkflowEventData<any>","handlerRootContext: HandlerContext","accept: AcceptEvents","handler: Handler<AcceptEvents, Result>","config?: WorkflowEventConfig<DebugLabel>","instance: WorkflowEventData<any>","data: Data","instance: unknown"],"sources":["../src/core/utils.ts","../src/core/context.ts","../src/core/workflow.ts","../src/core/event.ts"],"sourcesContent":["import type { WorkflowEvent, WorkflowEventData } from \"./event\";\n\nexport const isEventData = (data: unknown): data is WorkflowEventData<any> =>\n  data != null && typeof data === \"object\" && \"data\" in data;\n\nexport const isPromiseLike = (value: unknown): value is PromiseLike<unknown> =>\n  value != null && typeof (value as PromiseLike<unknown>).then === \"function\";\n\nexport function flattenEvents(\n  acceptEventTypes: WorkflowEvent<any>[],\n  inputEventData: WorkflowEventData<any>[],\n): WorkflowEventData<any>[] {\n  const acceptance: WorkflowEventData<any>[] = new Array(\n    acceptEventTypes.length,\n  );\n  for (const eventData of inputEventData) {\n    for (let i = 0; i < acceptEventTypes.length; i++) {\n      if (acceptance[i]) {\n        continue;\n      }\n      if (acceptEventTypes[i]!.include(eventData)) {\n        acceptance[i] = eventData;\n        break;\n      }\n    }\n  }\n  return acceptance.filter(Boolean);\n}\n\nexport type Subscribable<Args extends any[], R> = {\n  subscribe: (callback: (...args: Args) => R) => () => void;\n  publish: (...args: Args) => void;\n};\n\nconst __internal__subscribesSourcemap = new WeakMap<\n  Subscribable<any, any>,\n  Set<(...args: any[]) => any>\n>();\n\n/**\n * @internal\n */\nexport function getSubscribers<Args extends any[], R>(\n  subscribable: Subscribable<Args, R>,\n): Set<(...args: Args) => R> {\n  return __internal__subscribesSourcemap.get(subscribable)!;\n}\n\nexport function createSubscribable<Args extends any[], R>(): Subscribable<\n  Args,\n  R\n> {\n  const subscribers = new Set<(...args: Args) => R>();\n  const obj = {\n    subscribe: (callback: (...args: Args) => R) => {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    publish: (...args: Args) => {\n      for (const callback of subscribers) {\n        callback(...args);\n      }\n    },\n  };\n  __internal__subscribesSourcemap.set(obj, subscribers);\n  return obj;\n}\n","import type { WorkflowEvent, WorkflowEventData } from \"@llama-flow/core\";\nimport {\n  createSubscribable,\n  flattenEvents,\n  getSubscribers,\n  isEventData,\n  isPromiseLike,\n  type Subscribable,\n} from \"./utils\";\nimport { createAsyncContext } from \"@llama-flow/core/async-context\";\n\nexport type Handler<\n  AcceptEvents extends WorkflowEvent<any>[],\n  Result extends WorkflowEventData<any> | void,\n> = (\n  ...event: {\n    [K in keyof AcceptEvents]: ReturnType<AcceptEvents[K][\"with\"]>;\n  }\n) => Result | Promise<Result>;\n\ntype BaseHandlerContext = {\n  abortController: AbortController;\n  handler: Handler<WorkflowEvent<any>[], any>;\n  // events that are accepted by the handler\n  inputEvents: WorkflowEvent<any>[];\n  // events data that are accepted by the handler\n  inputs: WorkflowEventData<any>[];\n  // events data that are emitted by the handler\n  outputs: WorkflowEventData<any>[];\n\n  //#region linked list data structure\n  prev: HandlerContext;\n  next: Set<HandlerContext>;\n  root: HandlerContext;\n  //#endregion\n};\n\ntype SyncHandlerContext = BaseHandlerContext & {\n  async: false;\n  pending: null;\n};\n\ntype AsyncHandlerContext = BaseHandlerContext & {\n  async: true;\n  pending: Promise<WorkflowEventData<any> | void> | null;\n};\n\nexport type HandlerContext = AsyncHandlerContext | SyncHandlerContext;\n\nexport type ContextNext = (\n  context: HandlerContext,\n  next: (context: HandlerContext) => void,\n) => void;\n\nexport type WorkflowContext = {\n  get stream(): ReadableStream<WorkflowEventData<any>>;\n  get signal(): AbortSignal;\n  sendEvent: (...events: WorkflowEventData<any>[]) => void;\n\n  /**\n   * @internal\n   */\n  __internal__call_context: Subscribable<\n    Parameters<ContextNext>,\n    ReturnType<ContextNext>\n  >;\n  __internal__call_send_event: Subscribable<\n    [event: WorkflowEventData<any>, handlerContext: HandlerContext],\n    void\n  >;\n};\n\nexport const _executorAsyncLocalStorage = createAsyncContext<WorkflowContext>();\n\nexport function getContext(): WorkflowContext {\n  const context = _executorAsyncLocalStorage.getStore();\n  if (!context) {\n    throw new Error(\"No current context found\");\n  }\n  return context;\n}\n\nconst handlerContextAsyncLocalStorage = createAsyncContext<HandlerContext>();\n\nconst eventContextWeakMap = new WeakMap<\n  WorkflowEventData<any>,\n  HandlerContext\n>();\n\nexport type ExecutorParams = {\n  listeners: ReadonlyMap<\n    WorkflowEvent<any>[],\n    Set<Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>>\n  >;\n};\n\nexport const createContext = ({\n  listeners,\n}: ExecutorParams): WorkflowContext => {\n  const queue: WorkflowEventData<any>[] = [];\n  const runHandler = (\n    handler: Handler<WorkflowEvent<any>[], any>,\n    inputEvents: WorkflowEvent<any>[],\n    inputs: WorkflowEventData<any>[],\n    parentContext: HandlerContext,\n  ): void => {\n    let handlerAbortController: AbortController;\n    const handlerContext: HandlerContext = {\n      get abortController() {\n        if (!handlerAbortController) {\n          handlerAbortController = new AbortController();\n        }\n        return handlerAbortController;\n      },\n      async:\n        \"constructor\" in handler\n          ? handler.constructor.name === \"AsyncFunction\"\n          : false,\n      pending: null,\n      handler,\n      inputEvents,\n      inputs,\n      outputs: [],\n      prev: parentContext,\n      next: new Set(),\n      get root() {\n        return handlerRootContext;\n      },\n    };\n    handlerContext.prev.next.add(handlerContext);\n    const workflowContext = createWorkflowContext(handlerContext);\n    handlerContextAsyncLocalStorage.run(handlerContext, () => {\n      const cbs = [\n        ...new Set([\n          ...getSubscribers(rootWorkflowContext.__internal__call_context),\n          ...getSubscribers(workflowContext.__internal__call_context),\n        ]),\n      ];\n      _executorAsyncLocalStorage.run(workflowContext, () => {\n        //#region middleware\n        let i = 0;\n        const next = (context: HandlerContext) => {\n          if (i === cbs.length) {\n            let result: any;\n            try {\n              result = context.handler(...context.inputs);\n            } catch (error) {\n              if (handlerAbortController ?? rootAbortController) {\n                (handlerAbortController ?? rootAbortController).abort(error);\n              } else {\n                console.error(\"unhandled error in handler\", error);\n                throw error;\n              }\n            }\n            // return value is a special event\n            if (isPromiseLike(result)) {\n              (handlerContext as any).async = true;\n              (handlerContext as any).pending = result;\n              result.then((event) => {\n                if (isEventData(event)) {\n                  workflowContext.sendEvent(event);\n                }\n              });\n            } else if (isEventData(result)) {\n              workflowContext.sendEvent(result);\n            }\n          }\n          const cb = cbs[i];\n          if (cb) {\n            i++;\n            cb(context, next);\n          }\n        };\n        next(handlerContext);\n        //#endregion\n      });\n    });\n  };\n  const queueUpdateCallback = (handlerContext: HandlerContext) => {\n    const queueSnapshot = [...queue];\n    [...listeners]\n      .filter(([events]) => {\n        const inputs = flattenEvents(events, queueSnapshot);\n        return inputs.length === events.length;\n      })\n      .map(([events, handlers]) => {\n        const inputs = flattenEvents(events, queueSnapshot);\n        inputs.forEach((input) => {\n          queue.splice(queue.indexOf(input), 1);\n        });\n        for (const handler of handlers) {\n          runHandler(handler, events, inputs, handlerContext);\n        }\n      });\n  };\n  const createWorkflowContext = (\n    handlerContext: HandlerContext,\n  ): WorkflowContext => ({\n    get stream() {\n      let unsubscribe: () => void;\n      return new ReadableStream({\n        start: async (controller) => {\n          unsubscribe =\n            rootWorkflowContext.__internal__call_send_event.subscribe(\n              (newEvent: WorkflowEventData<any>) => {\n                let currentEventContext = eventContextWeakMap.get(newEvent);\n                while (currentEventContext) {\n                  if (currentEventContext === handlerContext) {\n                    controller.enqueue(newEvent);\n                    break;\n                  }\n                  currentEventContext = currentEventContext.prev;\n                }\n              },\n            );\n        },\n        cancel: () => {\n          if (unsubscribe) {\n            unsubscribe();\n          }\n        },\n      });\n    },\n    get signal() {\n      return handlerContext.abortController.signal;\n    },\n    sendEvent: (...events) => {\n      events.forEach((event) => {\n        eventContextWeakMap.set(event, handlerContext);\n        handlerContext.outputs.push(event);\n        queue.push(event);\n        rootWorkflowContext.__internal__call_send_event.publish(\n          event,\n          handlerContext,\n        );\n        queueUpdateCallback(handlerContext);\n      });\n    },\n    __internal__call_context: createSubscribable(),\n    __internal__call_send_event: createSubscribable(),\n  });\n\n  let rootAbortController = new AbortController();\n  const handlerRootContext: HandlerContext = {\n    get abortController() {\n      if (!rootAbortController) {\n        rootAbortController = new AbortController();\n      }\n      return rootAbortController;\n    },\n    async: false,\n    pending: null,\n    inputEvents: [],\n    inputs: [],\n    outputs: [],\n    handler: null!,\n    prev: null!,\n    next: new Set(),\n    get root() {\n      return handlerRootContext;\n    },\n  };\n\n  const rootWorkflowContext = createWorkflowContext(handlerRootContext);\n  return rootWorkflowContext;\n};\n","import { type WorkflowEvent, type WorkflowEventData } from \"./event\";\nimport { createContext, type Handler, type WorkflowContext } from \"./context\";\n\nexport type Workflow = {\n  handle<\n    const AcceptEvents extends WorkflowEvent<any>[],\n    Result extends ReturnType<WorkflowEvent<any>[\"with\"]> | void,\n  >(\n    accept: AcceptEvents,\n    handler: Handler<AcceptEvents, Result>,\n  ): void;\n  createContext(): WorkflowContext;\n};\n\nexport const createWorkflow = (): Workflow => {\n  const config = {\n    steps: new Map<\n      WorkflowEvent<any>[],\n      Set<Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>>\n    >(),\n  };\n\n  return {\n    handle: <\n      const AcceptEvents extends WorkflowEvent<any>[],\n      Result extends ReturnType<WorkflowEvent<any>[\"with\"]> | void,\n    >(\n      accept: AcceptEvents,\n      handler: Handler<AcceptEvents, Result>,\n    ): void => {\n      if (config.steps.has(accept)) {\n        const set = config.steps.get(accept) as Set<\n          Handler<AcceptEvents, Result>\n        >;\n        set.add(handler);\n      } else {\n        const set = new Set<Handler<AcceptEvents, Result>>();\n        set.add(handler);\n        config.steps.set(\n          accept,\n          set as Set<\n            Handler<WorkflowEvent<any>[], WorkflowEventData<any> | void>\n          >,\n        );\n      }\n    },\n    createContext() {\n      return createContext({\n        listeners: config.steps,\n      });\n    },\n  };\n};\n","declare const opaqueSymbol: unique symbol;\n\nconst eventMap = new WeakMap<WorkflowEvent<any>, WeakSet<object>>();\nconst refMap = new WeakMap<WorkflowEventData<any>, WorkflowEvent<any>>();\nlet i = 0;\nlet j = 0;\n\nexport type InferWorkflowEventData<T> =\n  T extends WorkflowEventData<infer U>\n    ? U\n    : T extends WorkflowEvent<infer U>\n      ? U\n      : never;\n\nexport type WorkflowEventData<Data, DebugLabel extends string = string> = {\n  get data(): Data;\n} & { readonly [opaqueSymbol]: DebugLabel };\n\nexport type WorkflowEvent<Data, DebugLabel extends string = string> = {\n  debugLabel?: DebugLabel;\n  with(data: Data): WorkflowEventData<Data, DebugLabel>;\n  include(event: unknown): event is WorkflowEventData<Data, DebugLabel>;\n} & { readonly [opaqueSymbol]: DebugLabel };\n\nexport type WorkflowEventConfig<DebugLabel extends string = string> = {\n  debugLabel?: DebugLabel;\n};\n\nexport const workflowEvent = <Data = void, DebugLabel extends string = string>(\n  config?: WorkflowEventConfig<DebugLabel>,\n): WorkflowEvent<Data, DebugLabel> => {\n  const l1 = `${i++}`;\n  const event = {\n    debugLabel: config?.debugLabel ?? l1,\n    include: (\n      instance: WorkflowEventData<any>,\n    ): instance is WorkflowEventData<Data> => s.has(instance),\n    with: (data: Data) => {\n      const l2 = `${j++}`;\n      const ref = {\n        [Symbol.toStringTag]:\n          config?.debugLabel ?? `WorkflowEvent(${l1}.${l2})`,\n        toString: () =>\n          config?.debugLabel ? config.debugLabel : `WorkflowEvent(${l1}.${l2})`,\n        toJSON: () => {\n          return {\n            type: config?.debugLabel ? config.debugLabel : l1,\n            data,\n          };\n        },\n        get data() {\n          return data;\n        },\n      } as unknown as WorkflowEventData<Data, DebugLabel>;\n      s.add(ref);\n      refMap.set(ref, event);\n      return ref;\n    },\n  } as unknown as WorkflowEvent<Data, DebugLabel>;\n\n  const s = new WeakSet();\n  eventMap.set(event, s);\n\n  Object.defineProperty(event, Symbol.toStringTag, {\n    get: () => event?.debugLabel ?? `WorkflowEvent<${l1}>`,\n  });\n\n  Object.defineProperty(event, \"displayName\", {\n    value: event?.debugLabel ?? `WorkflowEvent<${l1}>`,\n  });\n\n  event.toString = () => config?.debugLabel ?? `WorkflowEvent<${l1}>`;\n  return event;\n};\n\n// utils\nexport const eventSource = (\n  instance: unknown,\n): WorkflowEvent<any> | undefined =>\n  typeof instance === \"object\" && instance !== null\n    ? refMap.get(instance as any)\n    : undefined;\n"],"mappings":"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"}