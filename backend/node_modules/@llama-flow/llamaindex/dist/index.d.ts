type Handler<AcceptEvents extends (typeof WorkflowEvent<any>)[], Result extends WorkflowEvent<any> | void> = (...event: {
    [K in keyof AcceptEvents]: InstanceType<AcceptEvents[K]>;
}) => Result | Promise<Result>;
type StepContext<T = unknown> = {
    sendEvent: (event: WorkflowEvent<any>) => void;
    get stream(): ReadableStream<WorkflowEvent<any>>;
    get data(): T;
};
type StepHandler<ContextData, Inputs extends (typeof WorkflowEvent<any>)[], Outputs extends WorkflowEvent<any>[]> = (context: StepContext<ContextData>, ...args: Parameters<Handler<Inputs, Outputs[number]>>) => ReturnType<Handler<Inputs, Outputs[number]>>;
declare class WorkflowEvent<Data> {
    displayName: string;
    data: Data;
    constructor(data: Data);
    toString(): string;
}
declare class StartEvent<T = string> extends WorkflowEvent<T> {
    constructor(data: T);
}
declare class StopEvent<T = string> extends WorkflowEvent<T> {
    constructor(data: T);
}
declare class Workflow<ContextData, Start, Stop> {
    #private;
    addStep<const AcceptEvents extends (typeof WorkflowEvent<any>)[]>(parameters: {
        inputs: AcceptEvents;
    }, handler: (context: StepContext<ContextData>, ...args: Parameters<Handler<AcceptEvents, WorkflowEvent<any> | void>>) => ReturnType<Handler<AcceptEvents, WorkflowEvent<any> | void>>): void;
    run(start: Start, context?: ContextData): Promise<StopEvent<Stop>> & AsyncIterable<WorkflowEvent<any>> & {
        get data(): ContextData;
    };
}

export { StartEvent, StopEvent, Workflow, WorkflowEvent };
export type { StepContext, StepHandler };
