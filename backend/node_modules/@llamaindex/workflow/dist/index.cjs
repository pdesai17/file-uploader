Object.defineProperty(exports, '__esModule', { value: true });

var llamaindex = require('@llama-flow/llamaindex');
var memory = require('@llamaindex/core/memory');
var prompts = require('@llamaindex/core/prompts');
var tools = require('@llamaindex/core/tools');
var utils = require('@llamaindex/core/utils');
var zod = require('zod');
var global = require('@llamaindex/core/global');

class AgentToolCall extends llamaindex.WorkflowEvent {
}
class AgentToolCallResult extends llamaindex.WorkflowEvent {
}
class AgentInput extends llamaindex.WorkflowEvent {
}
class AgentSetup extends llamaindex.WorkflowEvent {
}
class AgentStream extends llamaindex.WorkflowEvent {
}
class AgentOutput extends llamaindex.WorkflowEvent {
}

const DEFAULT_SYSTEM_PROMPT = "You are a helpful assistant. Use the provided tools to answer questions.";
class FunctionAgent {
    constructor({ name, llm, description, tools, canHandoffTo, systemPrompt }){
        this.name = name ?? "Agent";
        this.llm = llm ?? global.Settings.llm;
        if (!this.llm.supportToolCall) {
            throw new Error("FunctionAgent requires an LLM that supports tool calls");
        }
        this.description = description ?? "A single agent that uses the provided tools or functions.";
        this.tools = tools;
        if (tools.length === 0) {
            throw new Error("FunctionAgent must have at least one tool");
        }
        // Process canHandoffTo to extract agent names
        this.canHandoffTo = [];
        if (canHandoffTo) {
            if (Array.isArray(canHandoffTo)) {
                if (canHandoffTo.length > 0) {
                    if (typeof canHandoffTo[0] === "string") {
                        // string[] case
                        this.canHandoffTo = canHandoffTo;
                    } else if (canHandoffTo[0] instanceof AgentWorkflow) {
                        // AgentWorkflow[] case
                        const workflows = canHandoffTo;
                        workflows.forEach((workflow)=>{
                            const agentNames = workflow.getAgents().map((agent)=>agent.name);
                            this.canHandoffTo.push(...agentNames);
                        });
                    } else {
                        // BaseWorkflowAgent[] case
                        const agents = canHandoffTo;
                        this.canHandoffTo = agents.map((agent)=>agent.name);
                    }
                }
            }
        }
        const uniqueHandoffAgents = new Set(this.canHandoffTo);
        if (uniqueHandoffAgents.size !== this.canHandoffTo.length) {
            throw new Error("Duplicate handoff agents");
        }
        this.systemPrompt = systemPrompt ?? DEFAULT_SYSTEM_PROMPT;
    }
    async takeStep(ctx, llmInput, tools) {
        // Get scratchpad from context or initialize if not present
        const scratchpad = ctx.data.scratchpad;
        const currentLLMInput = [
            ...llmInput,
            ...scratchpad
        ];
        const responseStream = await this.llm.chat({
            messages: currentLLMInput,
            tools,
            stream: true
        });
        let response = "";
        let lastChunk;
        const toolCalls = new Map();
        for await (const chunk of responseStream){
            response += chunk.delta;
            ctx.sendEvent(new AgentStream({
                delta: chunk.delta,
                response: response,
                currentAgentName: this.name,
                raw: chunk.raw
            }));
            const toolCallsInChunk = this.getToolCallFromResponseChunk(chunk);
            if (toolCallsInChunk.length > 0) {
                // Just upsert the tool calls with the latest one if they exist
                toolCallsInChunk.forEach((toolCall)=>{
                    toolCalls.set(toolCall.data.toolId, toolCall);
                });
            }
        }
        const message = {
            role: "assistant",
            content: response
        };
        if (toolCalls.size > 0) {
            message.options = {
                toolCall: Array.from(toolCalls.values()).map((toolCall)=>({
                        name: toolCall.data.toolName,
                        input: toolCall.data.toolKwargs,
                        id: toolCall.data.toolId
                    }))
            };
        }
        scratchpad.push(message);
        ctx.data.scratchpad = scratchpad;
        return new AgentOutput({
            response: message,
            toolCalls: Array.from(toolCalls.values()),
            raw: lastChunk?.raw,
            currentAgentName: this.name
        });
    }
    async handleToolCallResults(ctx, results) {
        const scratchpad = ctx.data.scratchpad;
        for (const result of results){
            const content = result.data.toolOutput.result;
            const rawToolMessage = {
                role: "user",
                content,
                options: {
                    toolResult: {
                        id: result.data.toolId,
                        result: content,
                        isError: result.data.toolOutput.isError
                    }
                }
            };
            ctx.data.scratchpad.push(rawToolMessage);
        }
        ctx.data.scratchpad = scratchpad;
    }
    async finalize(ctx, output, memory) {
        // Get scratchpad messages
        const scratchpad = ctx.data.scratchpad;
        for (const msg of scratchpad){
            memory.put(msg);
        }
        // Clear scratchpad after finalization
        ctx.data.scratchpad = [];
        return output;
    }
    getToolCallFromResponseChunk(responseChunk) {
        const toolCalls = [];
        const options = responseChunk.options ?? {};
        if (options && "toolCall" in options && Array.isArray(options.toolCall)) {
            toolCalls.push(...options.toolCall.map((call)=>{
                // Convert input to arguments format
                let toolKwargs;
                if (typeof call.input === "string") {
                    try {
                        toolKwargs = JSON.parse(call.input);
                    } catch (e) {
                        toolKwargs = {
                            rawInput: call.input
                        };
                    }
                } else {
                    toolKwargs = call.input;
                }
                return new AgentToolCall({
                    agentName: this.name,
                    toolName: call.name,
                    toolKwargs: toolKwargs,
                    toolId: call.id
                });
            }));
        }
        const invalidToolCalls = toolCalls.filter((call)=>!this.tools.some((tool)=>tool.metadata.name === call.data.toolName));
        if (invalidToolCalls.length > 0) {
            const invalidToolNames = invalidToolCalls.map((call)=>call.data.toolName).join(", ");
            throw new Error(`Tools not found: ${invalidToolNames}`);
        }
        return toolCalls;
    }
}

const DEFAULT_HANDOFF_PROMPT = new prompts.PromptTemplate({
    template: `Useful for handing off to another agent.
If you are currently not equipped to handle the user's request, or another agent is better suited to handle the request, please hand off to the appropriate agent.

Currently available agents: 
{agent_info}
`
});
const DEFAULT_HANDOFF_OUTPUT_PROMPT = new prompts.PromptTemplate({
    template: `Agent {to_agent} is now handling the request due to the following reason: {reason}.\nPlease continue with the current request.`
});
// Wrapper events for multiple tool calls and results
class ToolCallsEvent extends llamaindex.WorkflowEvent {
}
class ToolResultsEvent extends llamaindex.WorkflowEvent {
}
class AgentStepEvent extends llamaindex.WorkflowEvent {
}
/**
 * Create a multi-agent workflow
 * @param params - Parameters for the AgentWorkflow
 * @returns A new AgentWorkflow instance
 */ const multiAgent = (params)=>{
    return new AgentWorkflow(params);
};
/**
 * Create a simple workflow with a single agent and specified tools
 * @param params - Parameters for the single agent workflow
 * @returns A new AgentWorkflow instance
 */ const agent = (params)=>{
    return AgentWorkflow.fromTools(params);
};
/**
 * AgentWorkflow - An event-driven workflow for executing agents with tools
 *
 * This class provides a simple interface for creating and running agent workflows
 * based on the LlamaIndexTS workflow system. It supports single agent workflows
 * with multiple tools.
 */ class AgentWorkflow {
    constructor({ agents, rootAgent, verbose, timeout }){
        this.agents = new Map();
        this.handleInputStep = async (ctx, event)=>{
            const { userInput, chatHistory } = event.data;
            const memory = ctx.data.memory;
            if (chatHistory) {
                chatHistory.forEach((message)=>{
                    memory.put(message);
                });
            }
            if (userInput) {
                const userMessage = {
                    role: "user",
                    content: userInput
                };
                memory.put(userMessage);
            } else if (chatHistory) {
                // If no user message, use the last message from chat history as user_msg_str
                const lastMessage = chatHistory[chatHistory.length - 1];
                if (lastMessage?.role !== "user") {
                    throw new Error("Either provide a user message or a chat history with a user message as the last message");
                }
                ctx.data.userInput = lastMessage.content;
            } else {
                throw new Error("No user message or chat history provided");
            }
            return new AgentInput({
                input: await memory.getMessages(),
                currentAgentName: this.rootAgentName
            });
        };
        this.setupAgent = async (ctx, event)=>{
            const currentAgentName = event.data.currentAgentName;
            const agent = this.agents.get(currentAgentName);
            if (!agent) {
                throw new Error(`Agent ${currentAgentName} not found`);
            }
            const llmInput = event.data.input;
            if (agent.systemPrompt) {
                llmInput.unshift({
                    role: "system",
                    content: agent.systemPrompt
                });
            }
            return new AgentSetup({
                input: llmInput,
                currentAgentName: currentAgentName
            });
        };
        this.runAgentStep = async (ctx, event)=>{
            const agent = this.agents.get(event.data.currentAgentName);
            if (!agent) {
                throw new Error("No valid agent found");
            }
            if (this.verbose) {
                console.log(`[Agent ${agent.name}]: Running for input: ${event.data.input[event.data.input.length - 1]?.content}`);
            }
            const output = await agent.takeStep(ctx, event.data.input, agent.tools);
            ctx.sendEvent(new AgentStepEvent({
                agentName: agent.name,
                response: output.data.response,
                toolCalls: output.data.toolCalls
            }));
            ctx.sendEvent(output);
        };
        this.parseAgentOutput = async (ctx, event)=>{
            const { agentName, response, toolCalls } = event.data;
            // If no tool calls, return final response
            if (!toolCalls || toolCalls.length === 0) {
                if (this.verbose) {
                    console.log(`[Agent ${agentName}]: No tool calls to process, returning final response`);
                }
                const agentOutput = new AgentOutput({
                    response,
                    toolCalls: [],
                    raw: response,
                    currentAgentName: agentName
                });
                const content = await this.agents.get(agentName)?.finalize(ctx, agentOutput, ctx.data.memory);
                return new llamaindex.StopEvent({
                    result: content?.data.response.content
                });
            }
            return new ToolCallsEvent({
                agentName,
                toolCalls
            });
        };
        this.executeToolCalls = async (ctx, event)=>{
            const { agentName, toolCalls } = event.data;
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            const results = [];
            // Execute each tool call
            for (const toolCall of toolCalls){
                // Send single tool call event, useful for UI
                ctx.sendEvent(toolCall);
                const toolResult = new AgentToolCallResult({
                    toolName: toolCall.data.toolName,
                    toolKwargs: toolCall.data.toolKwargs,
                    toolId: toolCall.data.toolId,
                    toolOutput: {
                        id: toolCall.data.toolId,
                        result: "",
                        isError: false
                    },
                    returnDirect: false,
                    raw: {}
                });
                try {
                    const output = await this.callTool(toolCall, ctx);
                    toolResult.data.raw = output;
                    toolResult.data.toolOutput.result = utils.stringifyJSONToMessageContent(output);
                    toolResult.data.returnDirect = toolCall.data.toolName === "handOff";
                } catch (error) {
                    toolResult.data.toolOutput.isError = true;
                    toolResult.data.toolOutput.result = `Error: ${error}`;
                }
                results.push(toolResult);
                // Send single tool result event, useful for UI
                ctx.sendEvent(toolResult);
            }
            return new ToolResultsEvent({
                agentName,
                results
            });
        };
        this.processToolResults = async (ctx, event)=>{
            const { agentName, results } = event.data;
            // Get agent
            const agent = this.agents.get(agentName);
            if (!agent) {
                throw new Error(`Agent ${agentName} not found`);
            }
            await agent.handleToolCallResults(ctx, results);
            const directResult = results.find((r)=>r.data.returnDirect);
            if (directResult) {
                const isHandoff = directResult.data.toolName === "handOff";
                const output = typeof directResult.data.toolOutput.result === "string" ? directResult.data.toolOutput.result : JSON.stringify(directResult.data.toolOutput.result);
                const agentOutput = new AgentOutput({
                    response: {
                        role: "assistant",
                        content: output
                    },
                    toolCalls: [],
                    raw: output,
                    currentAgentName: agent.name
                });
                await agent.finalize(ctx, agentOutput, ctx.data.memory);
                if (isHandoff) {
                    const nextAgentName = ctx.data.nextAgentName;
                    console.log(`[Agent ${agentName}]: Handoff to ${nextAgentName}: ${directResult.data.toolOutput.result}`);
                    if (nextAgentName) {
                        ctx.data.currentAgentName = nextAgentName;
                        ctx.data.nextAgentName = null;
                        const messages = await ctx.data.memory.getMessages();
                        return new AgentInput({
                            input: messages,
                            currentAgentName: nextAgentName
                        });
                    }
                }
                return new llamaindex.StopEvent({
                    result: output
                });
            }
            // Continue with another agent step
            const messages = await ctx.data.memory.getMessages();
            return new AgentInput({
                input: messages,
                currentAgentName: agent.name
            });
        };
        this.workflow = new llamaindex.Workflow();
        this.verbose = verbose ?? false;
        // Handle AgentWorkflow cases for agents
        const processedAgents = [];
        if (agents.length > 0) {
            if (agents[0] instanceof AgentWorkflow) {
                // If agents is AgentWorkflow[], extract the BaseWorkflowAgent from each workflow
                const agentWorkflows = agents;
                agentWorkflows.forEach((workflow)=>{
                    const workflowAgents = workflow.getAgents();
                    processedAgents.push(...workflowAgents);
                });
            } else {
                // Otherwise, agents is already BaseWorkflowAgent[]
                processedAgents.push(...agents);
            }
        }
        // Handle AgentWorkflow case for rootAgent and set rootAgentName
        if (rootAgent instanceof AgentWorkflow) {
            // If rootAgent is an AgentWorkflow, check if it has exactly one agent
            const rootAgents = rootAgent.getAgents();
            if (rootAgents.length !== 1) {
                throw new Error(`Root agent must be a single agent, but it is a workflow with ${rootAgents.length} agents`);
            }
            // We know rootAgents[0] exists because we checked length === 1 above
            this.rootAgentName = rootAgents[0].name;
        } else {
            // Otherwise, rootAgent is already a BaseWorkflowAgent
            this.rootAgentName = rootAgent.name;
        }
        // Validate root agent
        if (!processedAgents.some((a)=>a.name === this.rootAgentName)) {
            throw new Error(`Root agent ${this.rootAgentName} not found in agents`);
        }
        this.addAgents(processedAgents);
    }
    addAgents(agents) {
        const agentNames = new Set(agents.map((a)=>a.name));
        if (agentNames.size !== agents.length) {
            throw new Error("The agent names must be unique!");
        }
        agents.forEach((agent)=>{
            this.agents.set(agent.name, agent);
        });
        if (agents.length > 1) {
            agents.forEach((agent)=>{
                this.validateAgent(agent);
                this.addHandoffTool(agent);
            });
        }
    }
    validateAgent(agent) {
        // Validate that all canHandoffTo agents exist
        const invalidAgents = agent.canHandoffTo.filter((name)=>!this.agents.has(name));
        if (invalidAgents.length > 0) {
            throw new Error(`Agent "${agent.name}" references non-existent agents in canHandoffTo: ${invalidAgents.join(", ")}`);
        }
    }
    addHandoffTool(agent) {
        if (agent.tools.some((t)=>t.metadata.name === "handOff")) {
            return;
        }
        const toHandoffAgents = new Map();
        agent.canHandoffTo.forEach((name)=>{
            toHandoffAgents.set(name, this.agents.get(name));
        });
        const handoffTool = createHandoffTool(toHandoffAgents);
        if (agent.canHandoffTo.length > 0 && !agent.tools.some((t)=>t.metadata.name === handoffTool.metadata.name)) {
            agent.tools.push(handoffTool);
        }
    }
    /**
   * Adds a new agent to the workflow
   */ addAgent(agent) {
        this.agents.set(agent.name, agent);
        this.validateAgent(agent);
        this.addHandoffTool(agent);
        return this;
    }
    /**
   * Gets all agents in this workflow
   * @returns Array of agents in this workflow
   */ getAgents() {
        return Array.from(this.agents.values());
    }
    /**
   * Create a simple workflow with a single agent and specified tools
   * @param params - Parameters for the single agent workflow
   * @returns A new AgentWorkflow instance
   */ static fromTools(params) {
        const agent = new FunctionAgent({
            name: params.name,
            description: params.description,
            tools: params.tools,
            llm: params.llm,
            systemPrompt: params.systemPrompt,
            canHandoffTo: params.canHandoffTo
        });
        const workflow = new AgentWorkflow({
            agents: [
                agent
            ],
            rootAgent: agent,
            verbose: params.verbose ?? false,
            timeout: params.timeout ?? 60
        });
        return workflow;
    }
    setupWorkflowSteps() {
        this.workflow.addStep({
            inputs: [
                llamaindex.StartEvent
            ]
        }, this.handleInputStep);
        this.workflow.addStep({
            inputs: [
                AgentInput
            ]
        }, this.setupAgent);
        this.workflow.addStep({
            inputs: [
                AgentSetup
            ]
        }, this.runAgentStep);
        this.workflow.addStep({
            inputs: [
                AgentStepEvent
            ]
        }, this.parseAgentOutput);
        this.workflow.addStep({
            inputs: [
                ToolCallsEvent
            ]
        }, this.executeToolCalls);
        this.workflow.addStep({
            inputs: [
                ToolResultsEvent
            ]
        }, this.processToolResults);
        return this;
    }
    callTool(toolCall, ctx) {
        const tool = this.agents.get(toolCall.data.agentName)?.tools.find((t)=>t.metadata.name === toolCall.data.toolName);
        if (!tool) {
            throw new Error(`Tool ${toolCall.data.toolName} not found`);
        }
        if (tool.metadata.requireContext) {
            const input = {
                context: ctx.data,
                ...toolCall.data.toolKwargs
            };
            return tool.call(input);
        } else {
            return tool.call(toolCall.data.toolKwargs);
        }
    }
    run(userInput, params) {
        if (this.agents.size === 0) {
            throw new Error("No agents added to workflow");
        }
        this.setupWorkflowSteps();
        const contextData = params?.context ?? {
            userInput: userInput,
            memory: new memory.ChatMemoryBuffer(),
            scratchpad: [],
            currentAgentName: this.rootAgentName,
            agents: Array.from(this.agents.keys()),
            nextAgentName: null
        };
        return this.workflow.run({
            userInput: userInput,
            chatHistory: params?.chatHistory
        }, contextData);
    }
}
const createHandoffTool = (agents)=>{
    const agentInfo = Array.from(agents.values()).reduce((acc, a)=>{
        acc[a.name] = a.description;
        return acc;
    }, {});
    return tools.FunctionTool.from(({ context, toAgent, reason })=>{
        if (!context) {
            throw new Error("Context is required for handoff");
        }
        const agents = context.agents;
        if (!agents.includes(toAgent)) {
            return `Agent ${toAgent} not found. Select a valid agent to hand off to. Valid agents: ${agents.join(", ")}`;
        }
        context.nextAgentName = toAgent;
        return DEFAULT_HANDOFF_OUTPUT_PROMPT.format({
            to_agent: toAgent,
            reason: reason
        });
    }, {
        name: "handOff",
        description: DEFAULT_HANDOFF_PROMPT.format({
            agent_info: JSON.stringify(agentInfo)
        }),
        parameters: zod.z.object({
            toAgent: zod.z.string({
                description: "The name of the agent to hand off to"
            }),
            reason: zod.z.string({
                description: "The reason for handing off to the agent"
            })
        }),
        requireContext: true
    });
};

exports.AgentInput = AgentInput;
exports.AgentOutput = AgentOutput;
exports.AgentSetup = AgentSetup;
exports.AgentStepEvent = AgentStepEvent;
exports.AgentStream = AgentStream;
exports.AgentToolCall = AgentToolCall;
exports.AgentToolCallResult = AgentToolCallResult;
exports.AgentWorkflow = AgentWorkflow;
exports.FunctionAgent = FunctionAgent;
exports.ToolCallsEvent = ToolCallsEvent;
exports.ToolResultsEvent = ToolResultsEvent;
exports.agent = agent;
exports.multiAgent = multiAgent;
Object.keys(llamaindex).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return llamaindex[k]; }
  });
});
